#
Решены:
- [x] [A. Камни и украшения](#a-камни-и-украшения)
- [x] [B. Последовательно идущие единицы](#b-последовательно-идущие-единицы)
- [x] [C. Удаление дубликатов](#c-удаление-дубликатов)
- [ ] [D. Генерация скобочных последовательностей](#d-генерация-скобочных-последовательностей)
- [x] [E. Анаграммы](#e-анаграммы)
- [ ] [G. Интересное путешествие](#g-интересное-путешествие)

## [A. Камни и украшения](A.py)

<table>
  <tr>
    <td>Ограничение времени</td>
    <td>1 секунда</td>
  </tr>
  <tr>
    <td>Ограничение памяти</td>
    <td>64Mb</td>
  </tr>
  <tr>
    <td>Ввод</td>
    <td>стандартный ввод или <code>input.txt</code></td>
  </tr>
  <tr>
    <td>Вывод</td>
    <td>стандартный вывод или <code>output.txt</code></td>
  </tr>
</table>

Даны две строки строчных латинских символов: строка J и строка S. Символы, входящие в строку J, — «драгоценности», входящие в строку S — «камни». Нужно определить, какое количество символов из S одновременно являются «драгоценностями». Проще говоря, нужно проверить, какое количество символов из S входит в J.

### Формат ввода

На двух первых строках входного файла содержатся две строки строчных латинских символов: строка J и строка S. Длина каждой не превосходит 100 символов.

### Формат вывода

Выходной файл должен содержать единственное число — количество камней, являющихся драгоценностями.

<table>
  <thead>
     <tr>
        <th>Ввод</th>
        <th>Вывод</th>
     </tr>
  </thead>
  <tbody>
     <tr>
        <td><pre>ab
aabbccd</pre></td>
        <td><pre>4</pre></td>
     </tr>
  </tbody>
</table>

## [B. Последовательно идущие единицы](B.py)

<table>
  <tr>
    <td>Ограничение времени</td>
    <td>1 секунда</td>
  </tr>
  <tr>
    <td>Ограничение памяти</td>
    <td>64Mb</td>
  </tr>
  <tr>
    <td>Ввод</td>
    <td>стандартный ввод или <code>input.txt</code></td>
  </tr>
  <tr>
    <td>Вывод</td>
    <td>стандартный вывод или <code>output.txt</code></td>
  </tr>
</table>

Требуется найти в бинарном векторе самую длинную последовательность единиц и вывести её длину.

Желательно получить решение, работающее за линейное время и при этом проходящее по входному массиву только один раз.

### Формат ввода
Первая строка входного файла содержит одно число n, n ≤ 10000. Каждая из следующих n строк содержит ровно одно число — очередной элемент массива.

### Формат вывода
Выходной файл должен содержать единственное число — длину самой длинной последовательности единиц во входном массиве.

### Пример

<table>
  <thead>
     <tr>
        <th>Ввод</th>
        <th>Вывод</th>
     </tr>
  </thead>
  <tbody>
     <tr>
        <td><pre>5
1
0
1
0
1
</pre></td>
        <td><pre>1
</pre></td>
     </tr>
  </tbody>
</table>

## [C. Удаление дубликатов](C.py)

<table>
  <tr>
    <th>Язык</th>
    <th>Ограничение времени</th>
    <th>Ограничение памяти</th>
    <th>Ввод</th>
    <th>Вывод</th>
  </tr>
  <tr>
    <td width="1%">Все языки</td>
    <td>1&nbsp;секунда</td>
    <td>10Mb</td>
    <td rowspan="5">стандартный ввод или <code>input.txt</code></td>
    <td rowspan="5">стандартный вывод или <code>output.txt</code></td>
  </tr>
  <tr>
    <td>
       <nobr>Oracle Java 7</nobr>
    </td>
    <td>1&nbsp;секунда</td>
    <td>20Mb</td>
  </tr>
  <tr>
    <td>
       <nobr>Node JS 8.9.4</nobr>
    </td>
    <td>1&nbsp;секунда</td>
    <td>20Mb</td>
  </tr>
  <tr>
    <td>
       <nobr>Oracle Java 8</nobr>
    </td>
    <td>1&nbsp;секунда</td>
    <td>20Mb</td>
  </tr>
  <tr>
    <td>
       <nobr>Kotlin</nobr>
    </td>
    <td>1&nbsp;секунда</td>
    <td>20Mb</td>
  </tr>
</table>
      
Дан упорядоченный по неубыванию массив целых 32-разрядных чисел. Требуется удалить из него все повторения.

Желательно получить решение, которое не считывает входной файл целиком в память, т.е., использует лишь константный объем памяти в процессе работы.

### Формат ввода
Первая строка входного файла содержит единственное число n, n ≤ 1000000.

На следующих n строк расположены числа — элементы массива, по одному на строку. Числа отсортированы по неубыванию.

### Формат вывода
Выходной файл должен содержать следующие в порядке возрастания уникальные элементы входного массива.

### Пример 1
<table>
  <thead>
     <tr>
        <th>Ввод</th>
        <th>Вывод</th>
     </tr>
  </thead>
  <tbody>
     <tr>
        <td><pre>5
2
4
8
8
8
  </pre></td>
        <td><pre>2
4
8
  </pre></td>
     </tr>
  </tbody>
</table>

### Пример 2

<table>
  <thead>
     <tr>
        <th>Ввод</th>
        <th>Вывод</th>
     </tr>
  </thead>
  <tbody>
     <tr>
        <td><pre>5
2
2
2
8
8
  </pre></td>
        <td><pre>2
8
  </pre></td>
     </tr>
  </tbody>
</table>

## D. Генерация скобочных последовательностей

<table>
  <tr>
    <td>Ограничение времени</td>
    <td>1 секунда</td>
  </tr>
  <tr>
    <td>Ограничение памяти</td>
    <td>20Mb</td>
  </tr>
  <tr>
    <td>Ввод</td>
    <td>стандартный ввод или <code>input.txt</code></td>
  </tr>
  <tr>
    <td>Вывод</td>
    <td>стандартный вывод или <code>output.txt</code></td>
  </tr>
</table>

Дано целое число n. Требуется вывести все правильные скобочные последовательности длины 2 ⋅ n, упорядоченные лексикографически (см. [https://ru.wikipedia.org/wiki/Лексикографический_порядок](https://ru.wikipedia.org/wiki/Лексикографический_порядок)).

В задаче используются только круглые скобки.

Желательно получить решение, которое работает за время, пропорциональное общему количеству правильных скобочных последовательностей в ответе, и при этом использует объём памяти, пропорциональный n.

### Формат ввода
Единственная строка входного файла содержит целое число n, 0 ≤ n ≤ 11

### Формат вывода
Выходной файл содержит сгенерированные правильные скобочные последовательности, упорядоченные лексикографически.

### Пример 1

<table>
  <thead>
     <tr>
        <th>Ввод</th>
        <th>Вывод</th>
     </tr>
  </thead>
  <tbody>
     <tr>
        <td><pre>2
</pre></td>
        <td><pre>(())
()()
</pre></td>
     </tr>
  </tbody>
</table>

### Пример 2

<table>
  <thead>
     <tr>
        <th>Ввод</th>
        <th>Вывод</th>
     </tr>
  </thead>
  <tbody>
     <tr>
        <td><pre>3
</pre></td>
        <td><pre>((()))
(()())
(())()
()(())
()()()
</pre></td>
     </tr>
  </tbody>
</table>

## [E. Анаграммы](E.py)

<table>
  <tr>
    <td>Ограничение времени</td>
    <td>1 секунда</td>
  </tr>
  <tr>
    <td>Ограничение памяти</td>
    <td>20Mb</td>
  </tr>
  <tr>
    <td>Ввод</td>
    <td>стандартный ввод или <code>input.txt</code></td>
  </tr>
  <tr>
    <td>Вывод</td>
    <td>стандартный вывод или <code>output.txt</code></td>
  </tr>
</table>

Даны две строки, состоящие из строчных латинских букв. Требуется определить, являются ли эти строки анаграммами, т. е. отличаются ли они только порядком следования символов.

### Формат ввода
Входной файл содержит две строки строчных латинских символов, каждая не длиннее 100 000 символов. Строки разделяются символом перевода строки.

### Формат вывода
Выходной файл должен содержать единицу, если строки являются анаграммами, и ноль в противном случае.

### Пример 1
<table>
  <thead>
     <tr>
        <th>Ввод</th>
        <th>Вывод</th>
     </tr>
  </thead>
  <tbody>
     <tr>
        <td><pre>qiu
iuq
</pre></td>
        <td><pre>1
</pre></td>
     </tr>
  </tbody>
</table>

### Пример 2
<table>
  <thead>
     <tr>
        <th>Ввод</th>
        <th>Вывод</th>
     </tr>
  </thead>
  <tbody>
     <tr>
        <td><pre>zprl
zprc
</pre></td>
        <td><pre>0
</pre></td>
     </tr>
  </tbody>
</table>


## [G. Интересное путешествие](G.py)

<table>
  <tr>
    <td>Ограничение времени</td>
    <td>1 секунда</td>
  </tr>
  <tr>
    <td>Ограничение памяти</td>
    <td>64Mb</td>
  </tr>
  <tr>
    <td>Ввод</td>
    <td>стандартный ввод или <code>input.txt</code></td>
  </tr>
  <tr>
    <td>Вывод</td>
    <td>стандартный вывод или <code>output.txt</code></td>
  </tr>
</table>

### Формат ввода
В первой строке входных данных записано количество городов $n$ $(2\leq n\leq 1000)$. В следующих $n$ строках даны два целых числа: координаты каждого города, не превосходящие по модулю миллиарда. Все города пронумерованы числами от 1 до $n$ в порядке записи во входных данных.

В следующей строке записано целое положительное число $k$, не превосходящее двух миллиардов, — максимальное расстояние между городами, которое Петя может преодолеть без дозаправки машины.

В последней строке записаны два различных числа — номер города, откуда едет Петя, и номер города, куда он едет. 

### Формат вывода
Если существуют пути, удовлетворяющие описанным выше условиям, то выведите минимальное количество дорог, которое нужно проехать, чтобы попасть из начальной точки маршрута в конечную. Если пути не существует, выведите -1. 

### Пример 1
<table>
  <thead>
     <tr>
        <th>Ввод</th>
        <th>Вывод</th>
     </tr>
  </thead>
  <tbody>
     <tr>
        <td><pre>7
0 0
0 2
2 2
0 -2
2 -2
2 -1
2 1
2
1 3
</pre></td>
        <td><pre>2
</pre></td>
     </tr>
  </tbody>
</table>

### Пример 2
<table>
  <thead>
     <tr>
        <th>Ввод</th>
        <th>Вывод</th>
     </tr>
  </thead>
  <tbody>
     <tr>
        <td><pre>4
0 0
1 0
0 1
1 1
2
1 4
</pre></td>
        <td><pre>1
</pre></td>
     </tr>
  </tbody>
</table>

### Пример 3
<table>
  <thead>
     <tr>
        <th>Ввод</th>
        <th>Вывод</th>
     </tr>
  </thead>
  <tbody>
     <tr>
        <td><pre>4
0 0
2 0
0 2
2 2
1
1 4
</pre></td>
        <td><pre>-1
</pre></td>
     </tr>
  </tbody>
</table>